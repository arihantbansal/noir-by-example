{
  "name": "PrivateCounter",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "headstart",
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 120
          },
          "visibility": "private"
        },
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "get",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "field"
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "increment",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/+2d93cbRRDHV5IluZMQwOlRKqQ5kuUip5FCQkkIJqGEHjk6G4NtBUkhMTWE3kOHhBJC76F3COT/4rHfvF08nAX84D2/3Puy7433pJP35rN3N7t7tztzUil1XI2miMnXmTw9vpSJ6zLiVcrNpjvb272uNi+TzeTTbd29uY50e0dvZy6Ty3TkOgptuWzWy7Xnurp7u7vS3Zn2rJfp6+jO9pmC4+50TAfBndBlJALgTpzm3EldRjIA7qRj7n+63ser51SHekZMXaZMeS1a/tAylTRfpmWaOWeol0mmXqadBnpNV39Prq+rGcrdPWrrL2rKm2E47PWFNFNLTHD8G1t6fCkzU7m9Z2yapaXGbEfF9zGTJwJgUb7j+Ouvucp3Tg8exMmZFUC5s5W7myMo7tnuz1Ggjc9sh3rGquiJNEdLndlOBFA/AdyUadsJVUJ3JGsUcFPWmhyp36tszw8XikObB7zBQqTKfyhRWsy3r05s232yS+S6yv6y5/Zgfns+R43a9ZQabT+tkjPN/pT43VxTXkyNTae7/a+ms0t9g6qHFuXezLjWcU4AOgah51wVTJ9inpYpZlve/Ep8V+NjgkmLO+arU6PmNyqOo9weJxuEOa5mIGVd1lSpS2m+4z5efG4S+5WvXprNbxOOz0FE6GfLrfHphmZlstkeLlYG+kY2lrx8xStsK1Y8eWElfBUiAaRRk/tlpSR95chKToo80M6nEgq7LHuectuxmYhRjUtrHhE62gtgvpYFWhaq0StMnnSbwtJJk7rbHBd4UrAp3357Zzu2rtlqlt1/zawT29Ii1bjVJQMLMsuUpTumPXt7Bwd2b/FG1g8XevKlykB+cH2hUPLK5WoXSayK8rKf6rc60pJIM+xvYmQFTYh18fdxcfWjr7rA5AtNfoaWRT4doj5dxjvMcnhnZxYpt5YtrsYm15Yt6lDnIPV0Oa4IUs/5IdFzgXLbov0/TgvHOE02LNaWnqvlPJMjyX65Et8lfHyygZENUa3Zlg2RbfFln7recT2Fccwku/3yWbb9ztaX7DnZ/6lVY89NXZVzUy+ONdn3O6XG9sBqHZ+XiNDFlpv0MSC374C8oYHKpuHdpZE9emy1tdgvOyK1gsWvP5K0Q3I8Z38fUWM7Svjc4Ja5TV7zShxb+erBpgahSxD3RaPbMk/Zuiahv2VtFDx2f61ga3LMFhHHtOXaz03BHfcUf/N/8DdX0aN5AvmbhW6NPj3rxP568V3UxyHtkv39hD16iAZQWbas8Q4cFiv3HYcgmKMOmZeEhDnmkHlpSJhrHDIvCwlz3CHz8pAwJxwyt4aEOemQeUVImKc7ZE6HhHmqQ+YMIXMbIXOWkLmdkLmDkLmTkLmLkDlHyNxNyLySkHkVIfNqQuY1hMxrCZnPJ2ReR8i8npB5AyHzRkLmCwiZNxEybyZkvpCQ+SJC5osJmS8hZN5CyLyVkPlSQuZthMyXETL3EDJfTsi8nZB5ByHzFYTMVxIyX0XIfDUh805C5msIma8lZL6OkPl6QuYbCJlvJGS+iZB5FyFznpC5l5B5NyFzgZDZI2TuI2TuJ2S+mZB5gJD5FkLmWwmZBwmZhwiZhwmZi4TMewiZbyNkLhEylwmZKyFhnuuQeS/heb6dkHkfIfN+QuYRQuY7CJnvJGS+i5D5bkLmewiZ7yVkPkDIfB8h80FC5vsJmR8gZH6QkPkhQuaHCZkfIWR+lJD5MULmxwmZnyBkfpKQ+SlC5qcJmQ8RMj9DyPwsIfNzhMzPEzK/QMj8IiHzS4TMLxMyv0LIfJiQ+Qgh86uEzK8RMr9OyPwGIfNRQuY3CZmPETK/Rcj8NiHzO4TM7xIyv0fI/D4h8weEzB8SMn9EyPwxIfMnhMyfEjJ/Rsh8nJD5c0LmLwiZvyRk/iokzLUOmb8OCXOdQ+ZvQsJc75D525AwNzhk/i4kzI0Omb8PCXOTQ+YfQsLc7JD5x5Awn+GQ+aeQME9yyPxzSJgnO2T+JSTMZzpk/jUkzFMcMp8ICfNZDpl/Cwnz2Q6Zfw8J8zkOmU86ZG4x5UQMc0xLjZa4loSWpBaMCTFGwpgBfWj0KdHHQp8DbTDaJNho2Czcw7imcY7B3CLq9IjJF2tZomWplmValmtp1bICPFoyWtpQT1ratXRo6dTSpSWnpVvLSi2rtKzWskbLWi02zj3ioG/QgjjZiBuNOMqIK4w4u4g7izisiEuKOJ2IW4k4johriDh/PVoQBw5x0RAnDHGzEEcKcZUQZ2inFsShQVwWxClB3A7EsUBcB8Q52KUFfvB7tcBPOvyGw482/ErDzzL8DsMPL/zSwk8r/JbCjyf8WsLP4x4t8AMIv3jwEwe/afAjBr9a8DO1Xwv8EMEvD/zUwG8L/JjArwf8XBzQAj8IB7VgnTzWjWMdNdYVY50t1p1iHSbWJWKdHtatYR0X1jVhnc8hLVgHgnURWCeAefOYR4551ZhnjHm3mId62JxPzNvDPDbM68I8p6NaMA/mmBbMk8C8AbxHx3tlvGfFe0e8h8N7KbynwXsLPMfHc20858VzTzwHxHMxPCfCcxM8R8C4GuNMjLswDkG/HP1U9NvQj0G7jnbuhBbYQdgF3Ce4rm1qMPlqk++oFEv5fi9VHixWUunUsP6bHxws7vMKrSm5r5wa2luupMqVfKmS6isVh1KZ1j8BGYu1Prm5AAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "events": [],
  "debug": {
    "debugSymbols": [
      "eJzt3d+O5TZywOF3mWsjUP0hKfpVglwY2Q2wwMIbxL4z5t0jI6PT3RvJ9CzZh79D8mqNxelRVXFOqcjpT/rty9//8Z8//fq3f/z8y5cff/uy/ZuELz/++29ffvnvn37+/f/45def/ufXLz9uP3z5689/Of736w9f/utvf//rlx/l6w//71PqHuzbJ4//junx6RwvPi4pnR/e3v5gC1//44ffA4mUQBIlkJ0SSIYEohslEKEEopRAjBKIUwKhdFaldFaldFaldFaldFajdFajdFajdFajdFajdFajdFajdFajdFajdFajdFandFandFandFandFandFandFandFandFandFandNZA6ayB0lkDpbMGSmcNlM4aKJ01UDproHTWQOmsgdJZI6WzRkpnjZTOGimdNVI6a6R01kjprJHSWSOls0ZKZ02UzpoonTVROmuidNZE6ayJ0lkTpbMmSmdNlM6aKJ11p3TWndJZd0pn3Smddad01p3SWXdKZ90pnXWndNad0lkzpbNmSmfNlM6aKZ01UzprpnTWTOmsmdJZM6WzZkpnlY3SWmWj9FbZKM1VNkp3lY3SXmWj9FfZKA1WNkqHlY3SYmXD9FjB9FjB9FjB9FjB9FjB9FiOyeKgLI7K4rAsjMsSDMwSjMwSDM0SjM0SDM4SjM4SDM8SjM8SDNASjNASDNESjNESDNISjNISDNMSjNMSDNQSjNQSDNUSjNUSDNYSjNYSDNcSjNcSDNgSjNgSDNkSjNkSDNoSjNoSDNsSjNsSDNwSjNwSDN0SjN0SDN4SjN4SDN8SjN8SDOASjOASDOESjOESDOISjOISDOMSjOMSDOQSjOQSDOUSjOUSDOYSjOYSDOcSjOcSDOgSjOgSDOkSjOkSDOoSjOoSDOsSjOsSDOwSjOwSDO0SjO0SDO4SjO4SDO8SjO8SDPASjPASDPESjPESDPISjPISDPMSjPNSjPNSjPNSjPNSjPPSjdJjFeO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8FOO8DOO8DOO8DOO8DOO8bKP0WMM4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8M4L8c4L8c4L8c4L8c4L98oPdYxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzssxzitgnFfAOK+AcV4B47zCRumxAeO8AsZ5BYzzChjnFTDOK2CcV8A4r4BxXgHjvALGeQWM8woY5xUwzitgnFfAOK+AcV4B47wCxnkFjPMKGOcVMM4rYJxXwDivgHFeAeO8AsZ5BYzzChjnFTDOK2CcV8A4r4BxXgHjvALGeQWM8woY5xUwzitgnFfAOK+AcV4B47wCxnkFjPMKGOcVMM4rYJxXwDivgHFeAeO8AsZ5BYzzChjnFTDOK2CcV8A4r4BxXgHjvALGeQWM8woY5xUwzitgnFfAOK+AcV4B47wCxnkFjPMKGOcVMM4rYJxXwDivgHFeAeO8AsZ5BYzzChjnFTDOK2CcV8A4r4BxXgHjvALGeQWM8woY5xUwzitgnFfAOK+AcV4B47wCxnkFjPMKGOcVMM4rYJxXwDiviHFeEeO8IsZ5RYzzihulx0aM84oY5xUxzitinFfEOK+IcV4R47wixnlFjPOKGOcVMc4rYpxXxDiviHFeEeO8IsZ5RYzzihjnFTHOK2KcV8Q4r4hxXhHjvCLGeUWM84oY5xUxzitinFfEOK+IcV4R47wixnlFjPOKGOcVMc4rYpxXxDiviHFeEeO8IsZ5RYzzihjnFTHOK2KcV8Q4r4hxXhHjvCLGeUWM84oY5xUxzitinFfEOK+IcV4R47wixnlFjPOKGOcVMc4rYpxXxDiviHFeEeO8IsZ5RYzzihjnFTHOK2KcV8Q4r4hxXhHjvCLGeUWM84oY5xUxzitinFfEOK+IcV4R47wixnlFjPOKGOcVMc4rYpxXxDiviHFeEeO8IsZ5RYzzihjnFTHOK2KcV8Q4r4hxXhHjvBLGeSWM80oY55UwzittlB6bMM4rYZxXwjivhHFeCeO8EsZ5JYzzShjnlTDOK2GcV8I4r4RxXgnjvBLGeSWM80oY55UwzithnFfCOK+EcV4J47wSxnkljPNKGOeVMM4rYZxXwjivhHFeCeO8EsZ5JYzzShjnlTDOK2GcV8I4r4RxXgnjvBLGeSWM80oY55UwzithnFfCOK+EcV4J47wSxnkljPNKGOeVMM4rYZxXwjivhHFeCeO8EsZ5JYzzShjnlSqdV94ekYTN6yKp67EtI6nrsS0jqeuxLSOp67EtI6nrsS0jqeuxLSOp67EtI6nrsQ0jqXReLSPB9NhK59UyEkyPrXReLSPB9NhK59UyEkyPrXReLSPB9NhK59UyEkyPrXReLSPB9NhK59UyEkyPrXReLSPB9NhK59UyEkyPrXReLSPB9NhK59UyEkyPrXReLSPB9NhK59UyEkyPrXReLSOh9Ni90nm1jITSY/dK59UyEkqP3TdKj90rnVfLSCg9dq90Xi0jofTYvdJ5NYyk0nm1jATTYyudV8tIMD220nm1jATTYyudV8tIMD220nm1jATTYyudV8tIMD220nm1jATTYyudV8tIMD220nm1jATTYyudV8tIMD220nm1jATTYyudV8tIMD220nm1jATTYyudV8tIMD220nm1jATTYyudV8tIMD220nm1jATTYyudV8tIMD220nm1jATTYyudV8tIMD220nm1jATTYyudV8tIMD220nm1jATTYyudV8tIMD220nm1jATTYyudV8tIMD0W47x2jPPaMc5rxzivHeO8dozz2jHOa8c4rx3jvHaM89oxzmvHOK8d47x2jPPaMc5rxzivHeO8dozz2jHOa8c4rx3jvHaM89oxzmvHOK8d47x2jPPaMc5rxzivHeO8dozz2jHOa8c4rx3jvHaM89oxzmvHOK8d47x2jPPKGOeVMc4rY5xXxjivvFF6bMY4r4xxXhnjvDLGeWWM88oY55UxzitjnFfGOK+McV4Z47wyxnlljPPKGOeVMc4rY5xXxjivjHFeGeO8MsZ5ZYzzyhjnlTHOK2OcV8Y4r4xxXhnjvDLGeWWM88oY55UxzitjnFfGOK+McV4Z47wyxnlljPPKGOeVMc4rY5xXxjivjHFeGeO8MsZ5ZYzzyhjnlTHOK2OcV8Y4r4xxXhnjvDLGeWWM88oY55UxzitjnFfGOK+McV4Z47wyxnlljPPKGOeVMc4rY5xXxjivjHFeGeO8MsZ5ZYzzyhjnlTHOK2OcV8Y4r4xxXhnjvDLGeWWM88oY55UxzitjnFfGOK+McV4Z47wyxnlljPPKGOeVMc4rY5xXxjivjHFeGeO8MsZ5ZYzzyhjnlTHOSzYM9DpCoXTZIxRKmz1CofTZIxRKoz1CoXTaIxRKqz1CofTaIxRKsz1C4XRbDPk6QuF0Wwz6OkLhdFsM+zpC4XRbDPw6QuF0Wwz9OkLhdFsM/jpC4XRbDP86QuF0WwwAO0LhdFsMATtC4XRbDAI7QuF0WwwDO0LhdFsMBDtC4XRbDAU7QuF0WwwGO0LhdFsMBztC4XRbDAg7QuF0WwwJO0LhdFsMCjtC4XRbDAs7QuF0WwwMO0LhdFsMDTtC4XRbDA47QuF0WwwPO0LhdFsMEDtC4XRbDBE7QuF0WwwSO0LhdFsMEztC4XRbDBQ7QuF0WwwVO0LhdFsMFjtC4XRbDBc7QuF0WwwYO0LhdFsMGTtC4XRbDBo7QuF0WwwbO0LhdFsMHDtC4XRbDB07QuF0WwweO0LhdFsMHztC4XRbDCA7QuF0WwwhO0LhdFsMIjtC4XRbDCM7QuF0WwwkO0LhdFsMJTtCwXRb4Vgy4Vgy4Vgy4Vgy2TDdVjiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDiWTDmWTDmWTDmWTDmWTDdMt1WOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJVOOJTOOJTOOJTOOJTOOJbMN022NY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mMY8mcY8mcY8mcY8mcY8l8w3Rb51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51gy51iywLFkgWPJAseSBY4lO36eEwqm2waOJQscSxY4lixwLFngWLLAsWSBY8kCx5IFjiULHEsWOJYscCxZ4FiywLFkgWPJAseSBY4lCxxLFjiWLHAsWeBYssCxZIFjyQLHkgWOJQscSxY4lixwLFngWLLAsWSBY8kCx5KFa0umW7Dzx2RL7wI6f+yyMxZ/7NpoqcgjSN3kD9M3S+HbZ4//jG+fle1xkcv+1Poil53n+y5i7y6SPlzk4tP7ns9PZ9HLkC47UN+QLjtR35AuO1LfkC47U9+QLjtU35CuO1XXkK67YM+Qrl1W35Aa9OPWIfG697XX6hsSr3tf+62+IfG697Xn6hsSr3tf+66uIV07r74h8br3tfvqGxKve187sL4h8br3tQvrG9KT+5Js/u3DIvb2WU9nQNceqmdAT/62ie5nQJovA3ryd60c0JO/aeWAnvw9Kwf05BmpHNCnTkjnRT61t3y7yLXo+b6LqL1dZC+UVn0/Q9Lw/k8Oj4PHa9nTN6QGU8x3hWTpvPOoy/4hpKsenB5/X7ccLxNo0IX7JtCga/dNoEGX/8QE3uI47uPhMoEGd4W+CTS4i/RNoMFd5zMTiPJIIOXLBBrc0bomcC2yXimBT723nhf51LvleZFPvaOdF/nUu855kU+9M5wX+dTufV7kUzvseZFP7YLnRT61U/3fReK1OGp9kSd84+O1Emp9kSd84+P2hG98vDY7rS/yhG98vHY2rS/yhG98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ZPaazF6T2Wsye01mr8nsNZm9JrPXZPaazF6T2Wsye01mr8nsNZm9JrPXZPaazF6T2Wsye01mr8nsNZm9JrPXZPaazF6T2Wsye01mr8nsNZm9JrPXZPaazF6T2Wsye01mr8nsNZm9JrPXZPaazF6T2Wsye01mr8nsNZm9JrPXZPaazF6T2Wsye01mr8nsNZm9JrPXZPaazF6T2Wsye01mr8nsNZm9JrPXZPaazF6T2Wsye01mr8nsNZm9JrPXZPaazF6T2Wsye01mr8nsNZm9JrPXZPaazF4ns9fJ7HUye53MXiez18nsdTJ7ncxeJ7PXyex1MnudzF4ns9fJ7HUye53MXiez18nsdTJ7ncxeJ7PXyex1MnudzF4ns9fJ7HUye53MXiez18nsdTJ7ncxeJ7PXyex1MnudzF4ns9fJ7HUye53MXiez18nsdTJ7ncxeJ7PXyex1MnudzF4ns9fJ7HUye53MXiez18nsdTJ7ncxeJ7PXyex1MnudzF4ns9fJ7HUye53MXiez18nsdTJ7ncxeJ7PXyex1MnudzF4ns9fJ7HUye53MXiez18nsdTJ7ncxeJ7PXyex1MnudzF4ns9fJ7HUye53MXiez18nsdTJ7ncxeJ7PXyex1MnudzF4ns9fJ7HUye53MXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavxey1mL0Ws9di9lrMXovZazF7LWavhezVPpC9rhhpyYqRlqwYacmKkZasGGnJipGWrBhpyYqRlqwYawmy1xVjLUH2umKsJcheV4y1BNnrirGWIHtdMdYSZK8rxlqC7HXFWEuQva4Yawmy1xVjLUH2umKsJcheV4y1BNnrirGWIHtdMdYSZK8rxlqC7HXFWEuQva4Yawmy1xVjLUH2umKsJcheV4y1BNnrirGW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1JAHNeRBDXlQQx7UkAc15EENeVBDHtSQBzXkQQ15UEMe1JAHNeRBDXlQQx7UkAc15EENeVBDHtSQBzXkQQ15UEMe1JAHNeRBDXlQQx7UkAc15EENeVBDHtSQBzXkQQ15UEMe1JAHNeRBDXlQQx7UkAc15EENeVBDHtSQBzXkQQ15UEMe1JAHNeRBDXlQQx7UkAc15EENeVBDHtSQBzXkQQ15UEMe1JAHNeRBDXlQQx7UkAc15EENeVBDHtSQBzXkQQ15UEMe1JAHNeRBDXlQQx7UkAc15EENeVBDHtSQBzXkQQ15UEMe1JAHNeRBDXlQQx7UkAc15EENeVBDDmrIQQ05qCEHNeSghhzUkIMaclBDDmrIQQ05qCEHNeSghhzUkIMaclBDDmrIQQ05qCEHNeSghhzUkIMaclBDDmrIQQ05qCEHNeSghhzUkIMaclBDDmrIQQ05qCEHNeSghhzUkIMaclBDDmrIQQ05qCEHNeSghhzUkIMaclBDDmrIQQ05qCEHNeSghhzUkIMaclBDDmrIQQ05qCEHNeSghhzUkIMaclBDDmrIQQ05qCEHNeSghhzUkIMaclBDDmrIQQ05qCEHNeSghhzUkIMaclBDDmrIQQ05qCEHNeSghhzUkIMaclBDDmrIQQ05qCEHNeSghhzUkIMaclBDDmrIQQ05qCEHNeSkhpzUkJMaclJDTmrISQ05qSEnNeSkhpzUkJMaclJDTmrISQ05qSEnNeSkhpzUkJMaclJDTmrISQ05qSEnNeSkhpzUkJMaclJDTmrISQ05qSEnNeSkhpzUkJMaclJDTmrISQ05qSEnNeSkhpzUkJMaclJDTmrISQ05qSEnNeSkhpzUkJMaclJDTmrISQ05qSEnNeSkhpzUkJMaclJDTmrISQ05qSEnNeSkhpzUkJMaclJDTmrISQ05qSEnNeSkhpzUkJMaclJDTmrISQ05qSEnNeSkhpzUkJMaclJDTmrISQ05qSEnNeSkhpzUkJMaclJDTmrISQ05qSEnNeSkhpzUkJMaclJDntSQJzXkSQ15UkOe1JAnNeRJDXlSQ57UkCc15EkNeVJDntSQJzXkSQ15UkOe1JAnNeRJDXlSQ57UkCc15EkNeVJDntSQJzXkSQ15UkOe1JAnNeRJDXlSQ57UkCc15EkNeVJDntSQJzXkSQ15UkOe1JAnNeRJDXlSQ57U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"
    ],
    "fileMap": {
      "1": {
        "source": "contract PrivateCounter {\n    use dep::std::option::Option;\n    use dep::aztec::{\n        context::{PrivateContext, PublicContext, Context},\n        note::{\n            note_header::NoteHeader,\n            utils as note_utils,\n        },\n        state_vars::map::Map,\n    };\n    use dep::value_note::{\n            balance_utils,\n            value_note::{\n                ValueNoteMethods,\n                VALUE_NOTE_LEN,\n            },\n    };\n    use dep::easy_private_state::easy_private_state::EasyPrivateUint;\n\n    struct Storage {\n        counts: Map<EasyPrivateUint>,\n    }\n\n    impl Storage {\n        fn init(context: Context) -> pub Self {\n            Storage {\n                counts: Map::new(\n                    context,\n                    1,\n                    |context, slot| {\n                        EasyPrivateUint::new(context, slot)\n                    },\n                ),\n            }\n        }\n    }\n\n    // Initialise storage with some secret headstart for the owner\n    #[aztec(private)]\n    fn constructor(headstart: u120, owner: Field) {\n        let storage = Storage::init(Context::private(&mut context));\n        let counts = storage.counts;\n        counts.at(owner).add(headstart, owner);\n    }\n\n    // Increment the owner's counter\n    #[aztec(private)]\n    fn increment(owner: Field) {\n        let storage = Storage::init(Context::private(&mut context));\n        let counts = storage.counts;\n        counts.at(owner).add(1, owner);\n    }\n\n    // A view function to get the owner's current count\n    unconstrained fn get(owner: Field) -> Field {\n        let storage = Storage::init(Context::none());\n        let counts = storage.counts;\n\n        // Return the sum of all notes in the set\n        balance_utils::get_balance(counts.at(owner).set)\n    }\n\n    // Computes note hash and nullifier\n    unconstrained fn compute_note_hash_and_nullifier(\n        contract_address: Field,\n        nonce: Field,\n        storage_slot: Field,\n        preimage: [Field; VALUE_NOTE_LEN]\n    ) -> [Field; 4] {\n        let note_header = NoteHeader::new(contract_address, nonce, storage_slot);\n        note_utils::compute_note_hash_and_nullifier(ValueNoteMethods, note_header, preimage)\n    }\n}\n",
        "path": "/home/sam/dev/noir-by-example/circuits/contracts/private-counter/src/main.nr"
      },
      "19": {
        "source": "struct GrumpkinScalar {\n    low: Field,\n    high: Field,\n}\n\nimpl GrumpkinScalar {\n    pub fn new(low: Field, high: Field) -> Self {\n        // TODO: check that the low and high value fit within the grumpkin modulus\n        GrumpkinScalar { low, high }\n    }\n}\n\nglobal GRUMPKIN_SCALAR_SERIALIZED_LEN: Field = 2;\n\npub fn deserialize_grumpkin_scalar(fields: [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN]) -> GrumpkinScalar {\n    GrumpkinScalar { low: fields[0], high: fields[1] }\n}\n\npub fn serialize_grumpkin_scalar(scalar: GrumpkinScalar) -> [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN] {\n    [scalar.low, scalar.high]\n}\n",
        "path": "std/grumpkin_scalar.nr"
      },
      "20": {
        "source": "use crate::grumpkin_scalar::GrumpkinScalar;\nuse crate::scalar_mul::fixed_base_embedded_curve;\n\npub fn grumpkin_fixed_base(scalar: GrumpkinScalar) -> [Field; 2] {\n    // TODO: this should use both the low and high limbs to do the scalar multiplication\n    fixed_base_embedded_curve(scalar.low, scalar.high)\n}\n",
        "path": "std/grumpkin_scalar_mul.nr"
      },
      "35": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option.nr"
      },
      "94": {
        "source": "use dep::protocol_types::constants::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    BLOCK_HEADER_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__BLOCK_HASH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\nuse crate::hash::pedersen_hash;\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_header: BlockHeader,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n    function_selector: Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.function_selector,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\n// docs:start:block-header\nstruct BlockHeader {\n    note_hash_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    archive_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:block-header\n\nimpl BlockHeader {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    pub fn serialize(self) -> [Field; BLOCK_HEADER_LENGTH] {\n        [\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.archive_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    pub fn deserialize(deserialized: [Field; BLOCK_HEADER_LENGTH]) -> Self {\n        BlockHeader {\n            note_hash_tree_root: deserialized[0],\n            nullifier_tree_root: deserialized[1],\n            contract_tree_root: deserialized[2],\n            l1_to_l2_messages_tree_root: deserialized[3],\n            archive_root: deserialized[4],\n            public_data_tree_root: deserialized[5],\n            global_variables_hash: deserialized[6],\n        }\n    }\n\n    pub fn empty() -> Self {\n        Self { note_hash_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, archive_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n\n    pub fn block_hash(self) -> Field {\n        // TODO(#3442): Unify the ordering in `BlockHeader::serialize` function and the ordering\n        // in the block hash preimage --> This requires changes in the circuits.\n        let inputs = [\n            self.global_variables_hash,\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.public_data_tree_root\n        ];\n        pedersen_hash(inputs, GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    pending_read_requests: [Field; crate::abi::MAX_PENDING_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        pedersen_hash(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_header: BlockHeader,\n    prover_address: Field,\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    pub fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_header.serialize());\n        inputs.push(self.prover_address);\n\n        pedersen_hash(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    pub fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n",
        "path": "/aztec/abi.nr"
      },
      "95": {
        "source": "use dep::protocol_types::constants::GENERATOR_INDEX__CONTRACT_ADDRESS;\nuse crate::hash::pedersen_hash;\n\npub fn compute_address(pub_key_x: Field, pub_key_y: Field, partial_address: Field) -> Field {\n    pedersen_hash([pub_key_x, pub_key_y, partial_address],\n        GENERATOR_INDEX__CONTRACT_ADDRESS)\n}\n",
        "path": "/aztec/address.nr"
      },
      "96": {
        "source": "use dep::protocol_types::constants::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    BlockHeader,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n    get_block_header::get_block_header,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n    pending_read_requests: BoundedVec<Field, MAX_PENDING_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_header: BlockHeader,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n            pending_read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_header: inputs.block_header,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_block_header(self, block_number: Field) -> BlockHeader {\n        get_block_header(block_number, self)\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            pending_read_requests: self.pending_read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.block_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_pending_read_request(&mut self, pending_read_request: Field) {\n        self.pending_read_requests.push(pending_read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_messages_tree_root, self.this_address(), self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                pending_read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 49),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 81),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 97),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 113),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 129),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 133),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 137),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 139),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 141),\n                encrypted_log_preimages_length: fields[143],\n                unencrypted_log_preimages_length: fields[144],\n                block_header: BlockHeader {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    note_hash_tree_root : fields[145],\n                    nullifier_tree_root : fields[146],\n                    contract_tree_root : fields[147],\n                    l1_to_l2_messages_tree_root : fields[148],\n                    archive_root : fields[149],\n                    public_data_tree_root: fields[150],\n                    global_variables_hash: fields[151],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[152], fields[153]),\n                    constructor_vk_hash : fields[154],\n                    function_tree_root : fields[155],\n                    contract_address_salt : fields[156],\n                    portal_contract_address : fields[157],\n                },\n                chain_id: fields[158],\n                version: fields[159],\n            },\n            is_execution_request: fields[160] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_header: BlockHeader::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_header: BlockHeader,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_header: inputs.block_header,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.inputs.block_header,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_messages_tree_root, this, self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}\n",
        "path": "/aztec/context.nr"
      },
      "97": {
        "source": "use dep::std::hash::{pedersen_hash_with_separator, sha256};\nuse dep::protocol_types::constants::{\n  GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n  GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET,\n};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    // TODO(#1205) This is probably not the right index to use\n    pedersen_hash([secret], GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET)\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    pedersen_hash_with_separator(inputs, hash_index)\n}\n",
        "path": "/aztec/hash.nr"
      },
      "98": {
        "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse crate::types::point::Point;\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n",
        "path": "/aztec/log.nr"
      },
      "103": {
        "source": "use crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse dep::protocol_types::constants::EMPTY_NULLIFIED_COMMITMENT;\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n    broadcast: bool\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialize = note_interface.serialize;\n    let serialized_note = serialize(*note);\n    assert(notify_created_note(storage_slot, serialized_note, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        let broadcast = note_interface.broadcast;\n        broadcast(context, storage_slot, *note);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note, note_interface: NoteInterface<Note, N>) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(nullifier, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}\n",
        "path": "/aztec/note/lifecycle.nr"
      },
      "104": {
        "source": "use dep::std::option::Option;\nuse dep::protocol_types::constants::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(context: PrivateContext, storage_slot: Field, note_interface: NoteInterface<Note, N>, note: Note) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        assert(fields[select.field_index] == select.value, \"Mismatch return note field.\");\n    }\n}\n\nfn check_notes_order<N>(fields_0: [Field; N], fields_1: [Field; N], sorts: BoundedVec<Option<Sort>, N>) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(context: &mut PrivateContext, storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let serialize = note_interface.serialize;\n            let fields = serialize(note);\n            check_note_header(*context, storage_slot, note_interface, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields)[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let opt_notes = oracle::notes::get_notes(storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields);\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(storage_slot: Field, note_interface: NoteInterface<Note, N>, options: NoteViewerOptions<Note, N>) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields)\n}\n\nunconstrained fn flatten_options<Note, N>(selects: BoundedVec<Option<Select>, N>, sorts: BoundedVec<Option<Sort>, N>) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}\n",
        "path": "/aztec/note/note_getter.nr"
      },
      "106": {
        "source": "use crate::hash::pedersen_hash;\nuse dep::protocol_types::constants::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\npub fn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([storage_slot, note_hash], 0)\n}\n\npub fn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\npub fn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n",
        "path": "/aztec/note/note_hash.nr"
      },
      "110": {
        "source": "use dep::protocol_types::constants::GENERATOR_INDEX__OUTER_NULLIFIER;\nuse crate::{\n    note::{\n        note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n    },\n    utils::arr_copy_slice,\n    hash::pedersen_hash,\n};\n\npub fn compute_inner_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\npub fn compute_unique_siloed_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note_with_header);\n\n    let input = [header.contract_address, inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_read_or_nullify<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n}\n\npub fn compute_note_hash_and_nullifier<Note, N, S>(note_interface: NoteInterface<Note, N>, note_header: NoteHeader, serialized_note: [Field; S]) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(serialized_note, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/aztec/note/utils.nr"
      },
      "119": {
        "source": "use crate::types::point::Point;\nuse crate::address::compute_address;\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: Field) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: Field) -> Point {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key_x = result[0];\n    let pub_key_y = result[1];\n    let partial_address = result[2];\n\n    let calculated_address = compute_address(pub_key_x, pub_key_y, partial_address);\n    assert(calculated_address == address);\n\n    Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/aztec/oracle/get_public_key.nr"
      },
      "120": {
        "source": "use crate::oracle::get_public_key::get_public_key;\nuse crate::types::point::Point;\n\n#[oracle(getSecretKey)]\nfn get_secret_key_oracle(_owner: Point) -> [Field; dep::std::grumpkin_scalar::GRUMPKIN_SCALAR_SERIALIZED_LEN] {}\n\nunconstrained fn get_secret_key_internal(owner_public_key: Point) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    dep::std::grumpkin_scalar::deserialize_grumpkin_scalar(get_secret_key_oracle(owner_public_key))\n}\n\npub fn get_secret_key(owner: Field) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    let owner_public_key = get_public_key(owner);\n    let secret = get_secret_key_internal(owner_public_key);\n\n    // Constrain the owner - Nullifier secret key is currently just the encryption private key so we can constrain\n    // the owner by deriving the public key from the secret key and checking the result.\n    let computed_public_key = dep::std::grumpkin_scalar_mul::grumpkin_fixed_base(secret);\n    assert(owner_public_key.x == computed_public_key[0]);\n    assert(owner_public_key.y == computed_public_key[1]);\n\n    secret\n}\n",
        "path": "/aztec/oracle/get_secret_key.nr"
      },
      "122": {
        "source": "#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n",
        "path": "/aztec/oracle/rand.nr"
      },
      "126": {
        "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(_storage_slot: Field, _serialized_note: [Field; N], _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(storage_slot: Field, serialized_note: [Field; N], inner_note_hash: Field) -> Field {\n    notify_created_note_oracle(storage_slot, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        return_size,\n        placeholder_fields)\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS] // TODO: Remove it and use `limit` to initialize the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = deserialize(serialized_note);\n            set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n",
        "path": "/aztec/oracle/notes.nr"
      },
      "128": {
        "source": "use crate::types::point::Point;\nuse dep::protocol_types::constants::NUM_FIELDS_PER_SHA256;\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(_contract_address: Field, _storage_slot: Field, _encryption_pub_key: Point, _preimage: [Field; N]) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(contract_address: Field, storage_slot: Field, encryption_pub_key: Point, preimage: [Field; N]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [emit_encrypted_log_oracle(contract_address, storage_slot, encryption_pub_key, preimage), 0]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(_contract_address: Field, _event_selector: Field, _message: T) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(contract_address: Field, event_selector: Field, message: T) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n",
        "path": "/aztec/oracle/logs.nr"
      },
      "134": {
        "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse crate::hash::pedersen_hash;\n\n// docs:start:map\nstruct Map<V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<V> Map<V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Map<V> {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map {\n            context,\n            storage_slot,\n            state_var_constructor,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: Field) -> V {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key],0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n",
        "path": "/aztec/state_vars/map.nr"
      },
      "136": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse dep::protocol_types::constants::{MAX_NOTES_PER_PAGE, MAX_READ_REQUESTS_PER_CALL};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\n\n// docs:start:struct\nstruct Set<Note, N> {\n    context: Context,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n}\n// docs:end:struct\n\nimpl<Note, N> Set<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Set {\n            context,\n            storage_slot,\n            note_interface,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:insert\n    pub fn insert(self,\n        note: &mut Note,\n        broadcast: bool,\n    ) {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n            broadcast,\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(\n            self.context.public.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:insert_from_public\n    \n    // DEPRECATED\n    fn assert_contains_and_remove(_self: Self, _note: &mut Note, _nonce: Field) {\n        assert(false, \"`assert_contains_and_remove` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\");\n    }\n\n    // DEPRECATED\n    fn assert_contains_and_remove_publicly_created(_self: Self, _note: &mut Note) {\n        assert(false, \"`assert_contains_and_remove_publicly_created` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\");\n    }\n\n    // docs:start:remove\n    pub fn remove(self, note: Note) {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_read_or_nullify(self.note_interface, note);\n        let has_been_read = context.read_requests.any(|r| r == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(\n            context,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n    ) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(\n            self.context.private.unwrap(),\n            storage_slot,\n            self.note_interface,\n            options,\n        );\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n        view_notes(self.storage_slot, self.note_interface, options)\n    }\n    // docs:end:view_notes\n}\n",
        "path": "/aztec/state_vars/set.nr"
      },
      "141": {
        "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n\n#[test]\nfn test_vec_push_pop() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    assert(vec.len == 0);\n    vec.push(2);\n    assert(vec.len == 1);\n    vec.push(4);\n    assert(vec.len == 2);\n    vec.push(6);\n    assert(vec.len == 3);\n    let x = vec.pop();\n    assert(x == 6);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test]\nfn test_vec_push_array() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test(should_fail)]\nfn test_vec_get_out_of_bound() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    let _x = vec.get(2);\n}\n\n#[test(should_fail)]\nfn test_vec_get_not_declared() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2]);\n    let _x = vec.get(1);\n}\n\n#[test(should_fail)]\nfn test_vec_get_uninitialized() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    let _x = vec.get(0);\n}\n\n#[test(should_fail)]\nfn test_vec_push_overflow() {\n    let mut vec: BoundedVec<Field, 1> = BoundedVec::new(0);\n    vec.push(1);\n    vec.push(2);\n}\n\n#[test]\nfn test_vec_any() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4, 6]);\n    assert(vec.any(|v| v == 2) == true);\n    assert(vec.any(|v| v == 4) == true);\n    assert(vec.any(|v| v == 6) == true);\n    assert(vec.any(|v| v == 3) == false);\n}\n\n#[test]\nfn test_vec_any_not_default() {\n    let default_value = 1;\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(default_value);\n    vec.push_array([2, 4]);\n    assert(vec.any(|v| v == default_value) == false);\n}\n",
        "path": "/aztec/types/vec.nr"
      },
      "147": {
        "source": "pub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: Field) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n\npub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() as u32 < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n",
        "path": "/aztec/utils.nr"
      },
      "148": {
        "source": "use dep::aztec::note::{\n    note_getter::view_notes,\n    note_viewer_options::NoteViewerOptions,\n};\nuse dep::aztec::state_vars::set::Set;\nuse crate::value_note::{VALUE_NOTE_LEN, ValueNote};\n\nunconstrained pub fn get_balance(set: Set<ValueNote, VALUE_NOTE_LEN>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(set: Set<ValueNote, VALUE_NOTE_LEN>, offset: u32) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let options = NoteViewerOptions::new().set_offset(offset);\n    let opt_notes = set.view_notes(options);\n    // docs:end:view_notes\n    let len = opt_notes.len();\n    for i in 0..len {\n        if opt_notes[i].is_some() {\n            balance += opt_notes[i].unwrap_unchecked().value;\n        }\n    }\n    if (opt_notes[len - 1].is_some()) {\n        balance += get_balance_with_offset(set, offset + opt_notes.len() as u32);\n    }\n\n    balance\n}\n",
        "path": "/value_note/balance_utils.nr"
      },
      "151": {
        "source": "use dep::aztec::{\n    note::{\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n        utils::compute_note_hash_for_read_or_nullify,\n    },\n    oracle::{\n        rand::rand,\n        get_secret_key::get_secret_key,\n        get_public_key::get_public_key,\n    },\n    log::emit_encrypted_log,\n    hash::pedersen_hash,\n    context::PrivateContext,\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: Field,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: Field) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote {\n            value,\n            owner,\n            randomness,\n            header,\n        }\n    }\n\n    pub fn serialize(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner, self.randomness]\n    }\n\n    pub fn deserialize(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: serialized_note[1],\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    pub fn compute_note_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize(),0)\n    }\n\n    // docs:start:nullifier\n\n    pub fn compute_nullifier(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_read_or_nullify(ValueNoteMethods, self);\n        let secret = get_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    pub fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    pub fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            encryption_pub_key,\n            self.serialize(),\n        );\n    }\n}\n\nfn deserialize(serialized_note: [Field; VALUE_NOTE_LEN]) -> ValueNote {\n    ValueNote::deserialize(serialized_note)\n}\n\nfn serialize(note: ValueNote) -> [Field; VALUE_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: ValueNote) -> Field {\n    note.compute_note_hash()\n}\n\nfn compute_nullifier(note: ValueNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: ValueNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut ValueNote, header: NoteHeader) {\n    note.set_header(header)\n}\n\n// Broadcasts the note as an encrypted log on L1.\nfn broadcast(context: &mut PrivateContext, slot: Field, note: ValueNote) {\n    note.broadcast(context, slot);\n}\n\nglobal ValueNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n    broadcast,\n};\n",
        "path": "/value_note/value_note.nr"
      },
      "152": {
        "source": "use dep::aztec::{\n    context::Context,\n    note::note_getter_options::NoteGetterOptions,\n    state_vars::set::Set,\n};\nuse dep::value_note::{\n    filter::filter_notes_min_sum,\n    value_note::{ValueNote, ValueNoteMethods, VALUE_NOTE_LEN},\n};\n\nstruct EasyPrivateUint {\n    context: Context,\n    set: Set<ValueNote, VALUE_NOTE_LEN>,\n    storage_slot: Field,\n}\n\nimpl EasyPrivateUint {\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = Set {\n            context,\n            storage_slot,\n            note_interface: ValueNoteMethods,\n        };\n        EasyPrivateUint {\n            context,\n            set,\n            storage_slot,\n        }\n    }\n\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u120, owner: Field) {\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner);\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note, true);\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u120, owner: Field) {\n        // docs:start:get_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let maybe_notes = self.set.get_notes(options);\n        // docs:end:get_notes\n\n        let mut minuend: u120 = 0;\n        for i in 0..maybe_notes.len() {\n            if maybe_notes[i].is_some() {\n                let note = maybe_notes[i].unwrap_unchecked();\n\n                // Ensure the notes are actually owned by the owner (to prevent user from generating a valid proof while\n                // spending someone else's notes).\n                assert(note.owner == owner);\n\n                // Removes the note from the owner's set of notes.\n                // docs:start:remove\n                self.set.remove(note);\n                // docs:end:remove\n\n                minuend += note.value as u120;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner);\n        self.set.insert(&mut result_note, result_value != 0);\n    }\n}\n",
        "path": "/easy_private_state/easy_private_state.nr"
      }
    }
  }
}